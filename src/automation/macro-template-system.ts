import { ParsedAbility, AbilityType, AutomationComplexity } from '../types';

/**
 * Professional macro template system for working automation
 * Generates executable macros based on chris-premades and gambits-premades patterns
 */
export class MacroTemplateSystem {

  /**
   * Generate complete macro integration for professional automation
   */
  public generateMacroIntegration(ability: ParsedAbility): MacroIntegration {
    const integration: MacroIntegration = {
      macros: [],
      flags: {},
      executionPoints: this.determineOptimalExecutionPoints(ability),
      validationLogic: this.generateValidationLogic(ability)
    };

    // Generate appropriate macros based on ability complexity
    if (ability.complexity >= AutomationComplexity.MODERATE) {
      integration.macros.push(this.generateMainAutomationMacro(ability));
    }

    if (ability.type === AbilityType.REACTION) {
      integration.macros.push(this.generateReactionTriggerMacro(ability));
    }

    if (this.hasOngoingEffects(ability)) {
      integration.macros.push(this.generateOngoingEffectsMacro(ability));
    }

    if (this.requiresMovementValidation(ability)) {
      integration.macros.push(this.generateMovementValidationMacro(ability));
    }

    if (this.hasComplexConditions(ability)) {
      integration.macros.push(this.generateConditionalLogicMacro(ability));
    }

    // Generate MidiQOL integration flags
    integration.flags = this.generateMacroFlags(ability, integration.executionPoints);

    return integration;
  }

  private generateMainAutomationMacro(ability: ParsedAbility): MacroTemplate {
    const macroName = `${ability.name.replace(/\s+/g, '')}Automation`;
    
    return {
      name: macroName,
      type: 'script',
      scope: 'global',
      content: this.buildMainMacroContent(ability),
      flags: {
        'chris-premades': {
          macroType: 'automation',
          abilityName: ability.name
        },
        automancy: {
          generated: true,
          phase: 2,
          complexity: ability.complexity
        }
      }
    };
  }

  private buildMainMacroContent(ability: ParsedAbility): string {
    const sections = [
      this.generateMacroHeader(ability),
      this.generateWorkflowValidation(),
      this.generatePreExecutionChecks(ability),
      this.generateMainLogic(ability),
      this.generatePostExecutionCleanup(ability),
      this.generateErrorHandling()
    ];

    return sections.join('\n\n');
  }

  private generateMacroHeader(ability: ParsedAbility): string {
    return `
// ${ability.name} Professional Automation Macro
// Generated by Automancy Phase 2 - Professional Grade
// Requires: MidiQOL, DAE, Active Effects
// Complexity: ${AutomationComplexity[ability.complexity]}

console.log("Executing ${ability.name} automation macro");

// Validate macro execution context
if (!args || !args[0]) {
  console.error("Invalid macro arguments for ${ability.name}");
  return;
}

const { workflow, actor, token, item, targets, macroPass } = args[0];
const macroName = "${ability.name.replace(/\s+/g, '')}Automation";`;
  }

  private generateWorkflowValidation(): string {
    return `
// Professional workflow validation
if (!workflow) {
  console.warn("No workflow found - macro may be executing outside expected context");
  return;
}

if (!workflow.token || !workflow.actor) {
  console.error("Invalid workflow state - missing token or actor");
  return false;
}

// Execution point validation
const validExecutionPoints = ["preItemRoll", "postAttackRoll", "postSave", "postDamageRoll", "preActiveEffects"];
if (!validExecutionPoints.includes(macroPass)) {
  console.log(\`Skipping execution at \${macroPass} - not a valid execution point\`);
  return;
}`;
  }

  private generatePreExecutionChecks(ability: ParsedAbility): string {
    let checks = `
// Pre-execution validation checks
try {`;

    // Resource availability checks
    if ((ability.resources?.consumed || 0) > 0) {
      checks += `
  // Check resource availability
  const resource = workflow.actor.system.resources.${ability.resources.type};
  if (!resource || resource.value < ${(ability.resources?.consumed || 1)}) {
    ui.notifications.warn("Insufficient resources for ${ability.name}");
    return false;
  }`;
    }

    // Recharge checks
    if (ability.raw.match(/recharge \d+/i)) {
      checks += `
  // Check recharge status
  if (!workflow.item.system.recharge?.charged) {
    ui.notifications.warn("${ability.name} is not charged!");
    return false;
  }`;
    }

    // Line of sight checks
    if (ability.raw.includes('can see')) {
      checks += `
  // Line of sight validation
  for (const target of workflow.targets) {
    const canSee = canvas.sight.testVisibility(workflow.token.center, target.center);
    if (!canSee) {
      ui.notifications.warn(\`Cannot see \${target.name} for ${ability.name}!\`);
      return false;
    }
  }`;
    }

    checks += `
} catch (error) {
  console.error("Pre-execution check failed:", error);
  return false;
}`;

    return checks;
  }

  private generateMainLogic(ability: ParsedAbility): string {
    let logic = `
// Main automation logic based on execution point
switch (macroPass) {`;

    // Pre-attack logic
    if (this.needsPreAttackLogic(ability)) {
      logic += `
  case "preAttackRoll":
    console.log("Executing pre-attack logic for ${ability.name}");
    ${this.generatePreAttackLogic(ability)}
    break;`;
    }

    // Post-attack logic
    if (ability.type === AbilityType.WEAPON_ATTACK || ability.type === AbilityType.SPELL_ATTACK) {
      logic += `
  case "postAttackRoll":
    console.log("Executing post-attack logic for ${ability.name}");
    ${this.generatePostAttackLogic(ability)}
    break;`;
    }

    // Save-based logic
    if (ability.saves.length > 0) {
      logic += `
  case "postSave":
    console.log("Executing post-save logic for ${ability.name}");
    ${this.generatePostSaveLogic(ability)}
    break;`;
    }

    // Damage logic
    if (ability.damage.length > 0) {
      logic += `
  case "postDamageRoll":
    console.log("Executing post-damage logic for ${ability.name}");
    ${this.generatePostDamageLogic(ability)}
    break;`;
    }

    // Effect application logic
    if (ability.effects.length > 0 || ability.conditions.length > 0) {
      logic += `
  case "preActiveEffects":
    console.log("Executing effect application logic for ${ability.name}");
    ${this.generateEffectApplicationLogic(ability)}
    break;`;
    }

    logic += `
  default:
    console.log(\`${ability.name}: No specific logic for execution point \${macroPass}\`);
}`;

    return logic;
  }

  private generatePreAttackLogic(ability: ParsedAbility): string {
    let logic = '';

    // Movement requirement validation (Deadly Leap)
    if (ability.raw.match(/leaps? at least (\d+) (?:feet|ft)/i)) {
      const distanceMatch = ability.raw.match(/leaps? at least (\d+) (?:feet|ft)/i);
      const requiredDistance = distanceMatch ? distanceMatch[1] : '10';
      
      logic += `
    // Validate leap distance requirement
    const requiredDistance = ${requiredDistance};
    const movementHistory = workflow.token.getFlag("automancy", "movementHistory") || [];
    const lastPosition = movementHistory[movementHistory.length - 1];
    
    if (lastPosition) {
      const distanceMoved = canvas.grid.measureDistance(lastPosition, workflow.token);
      if (distanceMoved < requiredDistance) {
        ui.notifications.warn(\`Must leap at least \${requiredDistance} feet toward target!\`);
        return false;
      }
      
      // Store leap validation for later use
      await workflow.token.setFlag("automancy", "validLeapExecuted", true);
    }`;
    }

    return logic || '    // No pre-attack logic required';
  }

  private generatePostAttackLogic(ability: ParsedAbility): string {
    let logic = '';

    // Hit-based effects
    if (ability.raw.includes('hits') && ability.saves.length > 0) {
      logic += `
    // On successful hit, force saving throw
    if (workflow.hitTargets.size > 0) {
      console.log("Hit detected, processing save requirements");
      
      for (const target of workflow.hitTargets) {
        // Save will be handled by postSave execution
        console.log(\`Target \${target.name} will make saving throw\`);
      }
    }`;
    }

    return logic || '    // No post-attack logic required';
  }

  private generatePostSaveLogic(ability: ParsedAbility): string {
    let logic = `
    // Process saving throw results
    const { failedSaves, saves } = workflow;
    
    if (failedSaves && failedSaves.size > 0) {
      console.log(\`\${failedSaves.size} targets failed their saves\`);
      
      // Apply conditions to failed saves
      for (const target of failedSaves) {
        try {`;

    // Apply prone condition
    if (ability.raw.includes('prone')) {
      logic += `
          // Apply prone condition
          const proneEffectData = {
            name: "${ability.name} - Prone",
            img: "systems/dnd5e/icons/conditions/prone.svg",
            origin: workflow.item.uuid,
            duration: { seconds: null },
            changes: [
              { key: "system.attributes.movement.walk", mode: 5, value: "0", priority: 20 },
              { key: "flags.midi-qol.disadvantage.attack.all", mode: 5, value: "1", priority: 20 },
              { key: "flags.midi-qol.grants.advantage.attack.mwak", mode: 5, value: "1", priority: 20 }
            ],
            flags: {
              dae: { stackable: "noneName", specialDuration: ["turnStart"] },
              "chris-premades": { condition: true, conditionType: "prone" }
            },
            statuses: ["prone"]
          };
          
          await MidiQOL.socket().executeAsGM("createEffects", {
            actorUuid: target.actor.uuid,
            effects: [proneEffectData]
          });`;
    }

    // Apply grapple condition
    if (ability.raw.includes('grappled')) {
      const escapeMatch = ability.raw.match(/escape DC (\d+)/i);
      const escapeDC = escapeMatch ? escapeMatch[1] : '15';
      
      logic += `
          // Apply grapple condition with escape DC ${escapeDC}
          const grappleEffectData = {
            name: "${ability.name} - Grappled",
            img: "systems/dnd5e/icons/conditions/grappled.svg",
            origin: workflow.item.uuid,
            duration: { seconds: null },
            changes: [
              { key: "system.attributes.movement.walk", mode: 5, value: "0", priority: 20 }
            ],
            flags: {
              dae: { stackable: "noneName", macroRepeat: "startEveryTurn" },
              "chris-premades": { 
                condition: true, 
                conditionType: "grappled",
                escapeDC: ${escapeDC},
                sourceToken: workflow.token.uuid
              }
            },
            statuses: ["grappled"]
          };
          
          await MidiQOL.socket().executeAsGM("createEffects", {
            actorUuid: target.actor.uuid,
            effects: [grappleEffectData]
          });`;
    }

    logic += `
        } catch (error) {
          console.error(\`Failed to apply effects to \${target.name}:\`, error);
        }
      }
    }
    
    if (saves && saves.size > 0) {
      console.log(\`\${saves.size} targets succeeded their saves\`);
      // Handle successful saves if needed
    }`;

    return logic;
  }

  private generatePostDamageLogic(ability: ParsedAbility): string {
    return `
    // Post-damage processing
    if (workflow.damageRoll) {
      console.log(\`Damage dealt: \${workflow.damageRoll.total}\`);
      
      // Track damage for reaction triggers
      for (const target of workflow.hitTargets) {
        const currentDamage = target.actor.getFlag("automancy", "damageTakenThisTurn") || 0;
        await target.actor.setFlag("automancy", "damageTakenThisTurn", currentDamage + workflow.damageRoll.total);
      }
    }`;
  }

  private generateEffectApplicationLogic(ability: ParsedAbility): string {
    return `
    // Handle effect application timing
    console.log("Applying additional effects for ${ability.name}");
    
    // Effects are primarily handled by Active Effects system
    // This is for any special timing or conditional logic
    
    // Reset temporary flags after effect application
    await workflow.token.unsetFlag("automancy", "validLeapExecuted");`;
  }

  private generatePostExecutionCleanup(ability: ParsedAbility): string {
    return `
// Post-execution cleanup
try {
  // Consume resources if needed
  ${this.generateResourceConsumption(ability)}
  
  // Update recharge status
  ${this.generateRechargeHandling(ability)}
  
  // Clean up temporary flags
  await workflow.token.unsetFlag("automancy", "temporaryFlags");
  
  console.log("${ability.name} automation completed successfully");
  
} catch (error) {
  console.error("Post-execution cleanup failed:", error);
}`;
  }

  private generateResourceConsumption(ability: ParsedAbility): string {
    if (!ability.resources || (ability.resources?.consumed || 1) <= 0) {
      return '// No resource consumption required';
    }

    return `
  // Consume ${(ability.resources?.consumed || 1)} ${ability.resources.type} resource(s)
  const currentResources = workflow.actor.system.resources.${ability.resources.type}.value;
  if (currentResources >= ${(ability.resources?.consumed || 1)}) {
    await workflow.actor.update({
      "system.resources.${ability.resources.type}.value": currentResources - ${(ability.resources?.consumed || 1)}
    });
    console.log("Consumed ${(ability.resources?.consumed || 1)} ${ability.resources.type} resource(s)");
  }`;
  }

  private generateRechargeHandling(ability: ParsedAbility): string {
    if (!ability.raw.match(/recharge \d+/i)) {
      return '// No recharge handling required';
    }

    const rechargeMatch = ability.raw.match(/recharge (\d+)(?:-(\d+))?/i);
    const minRoll = rechargeMatch ? rechargeMatch[1] : '6';
    const maxRoll = rechargeMatch && rechargeMatch[2] ? rechargeMatch[2] : '6';

    return `
  // Mark ability as used (needs recharge)
  await workflow.item.update({
    "system.recharge.charged": false,
    "system.recharge.value": ${minRoll}
  });
  
  console.log("${ability.name} used - requires recharge ${minRoll}-${maxRoll}");`;
  }

  private generateErrorHandling(): string {
    return `
// Global error handling
if (typeof workflow !== 'undefined' && workflow.aborted) {
  console.log("Workflow was aborted, cleaning up");
  return false;
}

return true;`;
  }

  private generateReactionTriggerMacro(ability: ParsedAbility): MacroTemplate {
    const macroName = `${ability.name.replace(/\s+/g, '')}ReactionTrigger`;
    
    return {
      name: macroName,
      type: 'script',
      scope: 'global',
      content: this.buildReactionTriggerContent(ability),
      flags: {
        'gambits-premades': {
          reactionTrigger: true,
          abilityName: ability.name
        }
      }
    };
  }

  private buildReactionTriggerContent(ability: ParsedAbility): string {
    const triggerType = this.extractReactionTrigger(ability.raw);
    
    return `
// ${ability.name} Reaction Trigger Macro
// Trigger: ${triggerType}

if (args[0].macroPass !== "${triggerType}") return;

const { actor, token, workflow } = args[0];

// Check if reaction already used
const reactionUsed = actor.getFlag("automancy", "reactionUsedThisRound");
if (reactionUsed) {
  console.log("Reaction already used this round");
  return;
}

// Specific trigger validation
${this.generateTriggerValidation(ability)}

// Prompt for reaction use
const useReaction = await Dialog.confirm({
  title: "${ability.name}",
  content: "<p>Trigger detected! Use your reaction for ${ability.name}?</p>"
});

if (useReaction) {
  // Mark reaction as used
  await actor.setFlag("automancy", "reactionUsedThisRound", true);
  
  // Execute the reaction ability
  const item = actor.items.find(i => i.name === "${ability.name}");
  if (item) {
    await item.use();
  }
}`;
  }

  private generateTriggerValidation(ability: ParsedAbility): string {
    if (ability.raw.includes('takes damage')) {
      return `
// Validate damage was taken
if (!workflow.damageRoll || workflow.damageRoll.total <= 0) {
  return;
}`;
    }

    if (ability.raw.includes('attacked')) {
      return `
// Validate this actor was targeted
if (!workflow.targets.has(token)) {
  return;
}`;
    }

    return '// No specific validation required';
  }

  private generateOngoingEffectsMacro(ability: ParsedAbility): MacroTemplate {
    const macroName = `${ability.name.replace(/\s+/g, '')}OngoingEffects`;
    
    return {
      name: macroName,
      type: 'script', 
      scope: 'global',
      content: this.buildOngoingEffectsContent(ability),
      flags: {
        dae: {
          macroRepeat: 'startEveryTurn'
        }
      }
    };
  }

  private buildOngoingEffectsContent(ability: ParsedAbility): string {
    const ongoingMatch = ability.raw.match(/takes? (\d+) \\(([^)]+)\\) (\\w+) damage at the start/i);
    if (!ongoingMatch) return '// No ongoing effects detected';

    const formula = ongoingMatch[2];
    const damageType = ongoingMatch[3].toLowerCase();

    return `
// ${ability.name} Ongoing Effects Macro
// Executes at start of each turn

if (args[0] !== "on" && !args[0].macroPass) return;

const { actor, token } = args[0];

try {
  // Check if parent effect still exists
  const parentEffect = actor.effects.find(e => 
    e.name.includes("${ability.name}") && e.name.includes("Grappled")
  );
  
  if (!parentEffect) {
    console.log("Parent effect ended, removing ongoing damage");
    return;
  }

  // Roll ongoing damage
  const damageRoll = await new Roll("${formula}").evaluate({ async: true });
  
  // Apply damage using MidiQOL
  await new MidiQOL.DamageOnlyWorkflow(
    parentEffect.origin?.actor || actor,
    token,
    damageRoll.total,
    "${damageType}",
    [token],
    damageRoll,
    {
      flavor: "${ability.name} - Ongoing ${damageType.charAt(0).toUpperCase() + damageType.slice(1)} Damage",
      itemCardId: "ongoing-damage"
    }
  );
  
  console.log(\`Applied \${damageRoll.total} ongoing ${damageType} damage to \${token.name}\`);
  
} catch (error) {
  console.error("Ongoing effects macro failed:", error);
}`;
  }

  private generateMovementValidationMacro(ability: ParsedAbility): MacroTemplate {
    const macroName = `${ability.name.replace(/\s+/g, '')}MovementValidation`;
    
    return {
      name: macroName,
      type: 'script',
      scope: 'global',
      content: this.buildMovementValidationContent(ability),
      flags: {
        automancy: {
          preExecutionValidation: true
        }
      }
    };
  }

  private buildMovementValidationContent(ability: ParsedAbility): string {
    const distanceMatch = ability.raw.match(/leaps? at least (\d+) (?:feet|ft)/i);
    const requiredDistance = distanceMatch ? distanceMatch[1] : '10';

    return `
// ${ability.name} Movement Validation Macro

// Hook into token movement to track leap distance
Hooks.on("updateToken", (tokenDocument, updateData, options, userId) => {
  if (!updateData.x && !updateData.y) return;
  
  const token = tokenDocument.object;
  if (!token) return;
  
  // Store movement history
  const history = token.getFlag("automancy", "movementHistory") || [];
  const currentPosition = { x: token.x, y: token.y };
  
  history.push(currentPosition);
  
  // Keep only last 5 positions
  if (history.length > 5) {
    history.shift();
  }
  
  token.setFlag("automancy", "movementHistory", history);
});

// Validation function for ${ability.name}
function validateLeapDistance(token, requiredDistance = ${requiredDistance}) {
  const history = token.getFlag("automancy", "movementHistory") || [];
  if (history.length < 2) return false;
  
  const lastPosition = history[history.length - 2];
  const currentPosition = { x: token.x, y: token.y };
  
  const distance = canvas.grid.measureDistance(lastPosition, currentPosition);
  return distance >= requiredDistance;
}

// Export for use by main automation macro
window.automancyValidation = window.automancyValidation || {};
window.automancyValidation.validateLeapDistance = validateLeapDistance;`;
  }

  private generateConditionalLogicMacro(ability: ParsedAbility): MacroTemplate {
    const macroName = `${ability.name.replace(/\s+/g, '')}ConditionalLogic`;
    
    return {
      name: macroName,
      type: 'script',
      scope: 'global',
      content: this.buildConditionalLogicContent(ability),
      flags: {
        automancy: {
          conditionalLogic: true
        }
      }
    };
  }

  private buildConditionalLogicContent(ability: ParsedAbility): string {
    return `
// ${ability.name} Conditional Logic Macro
// Handles complex conditional requirements

// Visibility check function
function checkLineOfSight(sourceToken, targetToken) {
  return canvas.sight.testVisibility(sourceToken.center, targetToken.center);
}

// Target type validation
function validateTargetType(target, requiredType) {
  return target.actor.system.details.type.value === requiredType.toLowerCase();
}

// Health-based conditions
function checkTargetHealth(target, condition) {
  const hp = target.actor.system.attributes.hp;
  
  switch (condition) {
    case "bloodied":
      return hp.value <= (hp.max / 2);
    case "unconscious":
      return hp.value <= 0;
    default:
      return true;
  }
}

// Resource availability check
function checkResourceAvailability(actor, resourceType, amount) {
  const resource = actor.system.resources[resourceType];
  return resource && resource.value >= amount;
}

// Export functions for use by main automation
window.automancyConditions = window.automancyConditions || {};
Object.assign(window.automancyConditions, {
  checkLineOfSight,
  validateTargetType,
  checkTargetHealth,
  checkResourceAvailability
});`;
  }

  // Helper methods
  private determineOptimalExecutionPoints(ability: ParsedAbility): string[] {
    const points: string[] = [];

    if (this.needsPreAttackLogic(ability)) {
      points.push('preAttackRoll');
    }

    if (ability.type === AbilityType.WEAPON_ATTACK || ability.type === AbilityType.SPELL_ATTACK) {
      points.push('postAttackRoll');
    }

    if (ability.saves.length > 0) {
      points.push('postSave');
    }

    if (ability.damage.length > 0) {
      points.push('postDamageRoll');
    }

    if (ability.effects.length > 0 || ability.conditions.length > 0) {
      points.push('preActiveEffects');
    }

    return points.length ? points : ['postItemRoll'];
  }

  private generateValidationLogic(ability: ParsedAbility): string[] {
    const validations: string[] = [];

    if (ability.raw.includes('can see')) {
      validations.push('line_of_sight');
    }

    if (ability.raw.match(/leaps? at least (\d+)/i)) {
      validations.push('movement_distance');
    }

    if ((ability.resources?.consumed || 0) > 0) {
      validations.push('resource_availability');
    }

    return validations;
  }

  private generateMacroFlags(ability: ParsedAbility, executionPoints: string[]): Record<string, any> {
    // NOTE: We don't generate macro flags because the macros would need to be
    // created separately in Foundry. Return empty object to avoid overwriting base flags.
    const flags: Record<string, any> = {};

    // Only add dae flags if we have ongoing effects (macroRepeat is useful even without custom macros)
    if (this.hasOngoingEffects(ability)) {
      flags.dae = {
        macroRepeat: 'startEveryTurn'
      };
    }

    return flags;
  }

  private needsPreAttackLogic(ability: ParsedAbility): boolean {
    return ability.raw.match(/leaps? at least (\d+)/i) !== null ||
           ability.raw.includes('can see') ||
           (ability.resources?.consumed || 0) > 0;
  }

  private hasOngoingEffects(ability: ParsedAbility): boolean {
    return ability.raw.includes('at the start of each turn') ||
           ability.raw.includes('ongoing damage');
  }

  private requiresMovementValidation(ability: ParsedAbility): boolean {
    return ability.raw.match(/leaps? at least (\d+)/i) !== null;
  }

  private hasComplexConditions(ability: ParsedAbility): boolean {
    return ability.raw.includes('can see') ||
           ability.raw.includes('bloodied') ||
           ability.raw.includes('humanoid');
  }

  private extractReactionTrigger(text: string): string {
    if (text.includes('takes damage')) return 'isDamaged';
    if (text.includes('attacked')) return 'isAttacked';
    if (text.includes('spell cast')) return 'preCastSpell';
    if (text.includes('moves')) return 'preMove';
    return 'manual';
  }
}

// Type definitions for macro system
interface MacroIntegration {
  macros: MacroTemplate[];
  flags: Record<string, any>;
  executionPoints: string[];
  validationLogic: string[];
}

interface MacroTemplate {
  name: string;
  type: 'script' | 'chat';
  scope: 'global' | 'actor' | 'world';
  content: string;
  flags?: Record<string, any>;
}